# for循环
- ## for(初始化;条件;循环体){执行体;}
  - ### （;;）里都可以不写
  - 满足条件执行


# break
- ## 退出当前循环
# continue
- ## 从此刻跳过这次循环，进入下一个循环

# 嵌套循环
# goto
- ## 定义一个标志，跳到标志后执行
 ```cpp
 #include <iostream>
 int main() {
    for( ; ; ){
        for(){
            goto FLAG;//会跳到下面的hello不会执行world
            cout << "world" 
        }
    }
    FLAG:
    cout << "hello"
 }
```
# 数组 arr[]
- ## 分配n个空间，但第n项下标是n-1
  - ## 例如 
  ```cpp
  int a[6]; //分配了6个空间
  ```
  - - ## a[5]即是第6个
- ## 定义
  - 数据类型 名[];
  - 类型 名[n]={};
  - 类型 名[]= {};得填完{}里的

 
- ## 内存大小 sizeof(arr) sizeof(a[0])
- ## arr数组名查询首地址，数组名是常量不可赋值

# 排序
- ### 交换
  - ```cpp
    int temp = arr[j];
    arr[j] = arr[j+1];
    arr[j+1] = temp;
- ## 冒泡排序
  - 外层循环：代表第几轮冒泡
  - 内层循环：负责把最大的往后冒
  - 遍历比较相邻两个，大的交换；每轮确定一个最大数；轮数=n-1
  -  ```cpp
     for(int i = 0; i < 10 - 1; i++){
                                   //轮数 = 元素个数 - 1；
                for(int j = 0; j < 10 - i - 1; j++){
                                     //每一轮排序几次 = 元素个数 - 轮数 - 1；
                                     //减一意义是 间隔数 ，比较只需两个进行即可
                                     
- ## 选择排序
  - 外层循环：代表要确定第几个位置
  - 内层循环：负责在未排区域找最小值/最大值
  - ```cpp
    for(int i = 0; i < n -1; i++){
                int min = i;
                for(int j = i + 1; j < n; j++){
                        if(a[j] < a[min]){
                                min = j;
                        }
                }
  - 两层循环
  - 每次选择一个最小的数，把他放在最前
  - 每次的min从i开始
  - 交换
    - ```cpp
      int temp;
      temp = a[i];
      a[i] = a[min];
      a[min] = temp; 
      ```
- ## 插入排序
  - 外层循环：代表要插入第几个数
  - 内层循环：代表往前找插入点 & 移动元素
  - 从第二个开始选出一个，给x，与前面的比较，符合，前面的往后挪，再与更前面比较，让后把最后符合的前一个，x给它
  - 主体
  ```cpp
    for(int i = 1; i < n; i++){
                int x = a[i];
                int j = i - 1;
                while(j >= 0 && x > a[j]){
                        a[j+1] = a[j];
                        j--;
                }
                a[j+1] = x;
    }
  ```
  - 两层循环，外层决定了要 ***拿几次*** ，内层决定了要 ***比几次***
  - 交换体现在内层a[j+1] = a[j]//把a[j]往后移//然后往前走一个,j--,再把提出来的给放在空的位上， a[j+1] = x//插入至a[j]变化后的j+1
  
## 二维数组
- ### 定义可读性
  ```cpp
  int a[2][3] ={
    {2,3,4},
    {2,3,5}
  };
  ```
- ### 文件名
  - 查看内存大小
  - - 二维数组的，第几行的，每个元素 
  - 查看首地址
  - - 二维数组的= 第一行的 = 第一个元素的（&arr[0][0]）
- #### 字符数组，头文件string
# 函数
- ```cpp
  /*返回值类型 函数名（输入参数1，输入参数2，）{
    函数体
    return表达式；
  }
  ```
- 调用
  无返回无参数
  直接写： 名（）
- ## 有参？有返？
   有参有返

   有参无返

   无参有反

   无参无返
   
  void

- ## 实参形参
  - 实参：main函数里定义的函数
  - 形参：函数的输入值
  - 值传递 形参改变不了实参
- 函数声明
  - 声明可以多次，定义只能一次
  
- ## 分文件书写
- 头文件
- - .h文件，函数声明，（包含其他头文件）
- 源文件
- - 自定义的“”，函数定义，
  
# 指针
- ## 定义
- ## 空指针 和 野指针
  - 空指针
    ```cpp
    int * p = NULL;
    ```
  - 野指针
    ```cpp
    int * p = int *(0x1111)//此位置的东西是未知的
    ```
- ## const修饰指针
  - 常量指针(指向可变，值不能)
    ```cpp
    const int * p = &a;//指向可变，指向的值不能变
    //如果有b=10，a= 10,可以p=&b
    ```
  - 指针常量(指向不可变，值可变)
    ```cpp
    int * const p = &a;//如果有b=10，a= 10,不可以p=&b
    ```
  - const既修饰指针，又修饰常量(值和指向均不变)
    ```cpp
    const int * const p = &a;
    ```
- ## 指针和数组
   ```cpp
   int a[]={,,,}
   int * p = a;//指向数组首地址，即a[0]，无需 &
   p++;
   cout << *p;//for循环遍历输出，
   ```
- ## 指针和函数
  - 值传递 和 地址传递
  - 值传递不改变实参，地址传递不改变地址但 ***会改变实参***
   ```cpp
   //地址传递
   void swap1(int * p1,int * p2){
    int temp = * p1;
    *p1 = *p2;
    *p2 = temp;
   }
   int main(){
    int a = 9,int b = 8;
    swap1(&a,&b)
    cout << a<< b;
    //值会改变
   }
   ```
  - 有种索引的意味
  - ```cpp
    //实际案例
    void sort(int * p,int len){}//用指针去接数组
    int main(){
      int a[]={};
      int len = sizeof(a) /sizeof(a[0]);
      sort(a,len);
    }
    ```
- # 结构体
  - ## 定义 （struct 不可以省略）
  - ```cpp
     struct student {
      //列表
      int a;
      string name;//注意加<string>/<cstring>头文件
      double score;
     };// *** ；不要省略 ***
     ```
  - ## 创建变量 （struct 可以省略）
    - ```cpp
      //第一种
      struct student s1;
      //再详细定义内容
      s1.name = ...;// ## 通过“ . ”访问元素

      //第二种
      struct student s1 ={...,...,...};

      //第三种
      }s1;//紧跟结构体后面，开始便定义
      ```

  - ## 注意
    -  用“.”访问
    -  定义struct不可以省略
    -  创建变量时可以省略

- # 结构体数组
  - ```cpp  
    student arr[5];
    student arr[5]= {
      {},
      {},
      {},
      {},
      {}
    };
    ```
- # 结构体指针
  - 定义：student * p = &s1;
  - 访问元素：“->”, p->name
- # 值传递 与 地址传递
- 值传递不会改变实参，地址传递会
  ```cpp
   void print( student s){}，
   print(s)
   void print( student * p){
   p->name
   }
   print(&s)
   ```
- const修饰
- ```cpp
   void print(student const * p){}//指针节省内存，值传递会复制同类型
  